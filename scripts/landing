#!/usr/bin/env python

import os
import sys
import math
import time
import rospy
import numpy

from std_msgs.msg       import String
from std_msgs.msg       import Float64
from nav_msgs.msg       import Odometry
from sensor_msgs.msg    import Range
from geometry_msgs.msg  import PoseStamped

from offboard_control.srv  import flight_mode as OffMode

class LandingControl() :

    def __init__(self) :
        '''
            Test node to land a UAV on a UGV based on UWB ranging.
            Landing options:
                - Use external UWB anchors to position both vehicles
                - Use single UAV-UGV range measurement + VIO on both vehicles
                - Use multiple UWB transceivers on UGV to estimate relative positions
                - Use multiple UWB transceivers on both UGV and UAV to estimate relative poses
        '''

        # Init node
        rospy.init_node('UWB_VIO_Landing', anonymous=False)

        # Positions for navigation
        self.pos = PoseStamped()
        self.uav_uwb_pos = PoseStamped()
        self.ugv_uwb_pos = PoseStamped()
        self.objective = PoseStamped()

        self.max_pos_delay = rospy.get_param("~max_pos_delay", 0.2)
        self.waypoint_step = rospy.get_param("~waypoint_step", 0.2)

        # Control altitudes
        self.approaching_altitude = rospy.get_param("~approaching_altitude", 1.2)
        self.closing_altitude = rospy.get_param("~closing_altitude", 0.8)
        self.landing_altitude = rospy.get_param("~landing_altitude", 0.48)

        self.closing_dist = rospy.get_param("~closing_dist", 1)
        self.landing_dist = rospy.get_param("~landing_dist", 0.1)

        # Publish distance to target in a topic
        self.dist_to_target_topic = rospy.get_param("~dist_to_target_topic", "landing/distance")
        self.dist_to_target = -1
        self.dist_to_target_pub = rospy.Publisher(self.dist_to_target_topic, Range, queue_size=10)

        # Get pos from PX4 EKF2 that already integrates VIO and/or others
        self.local_pos_topic =  rospy.get_param("~local_pos_topic", "/uav/mavros/local_position/pose")
        rospy.loginfo("Subscribing to local (mavros) position at {}".format(self.local_pos_topic))

        self.local_pos_sub = rospy.Subscriber(self.local_pos_topic, PoseStamped, self.update_current_pos_cb)

        # Wait to get local pos lock
        sys.stdout.write("Waiting for (mavros) local pos lock...")
        while not self.pos.header.stamp :
            sys.stdout.write("..")
            sys.stdout.flush()
            time.sleep(0.1)
        self.home_pos = self.pos
        rospy.loginfo("Home position locked: \n{}".format(self.pos.pose))

        # UWB Subscribers
        self.uav_uwb_topic = rospy.get_param("~uav_uwb_topic", "/dwm1001/tag/dronie/position")
        self.ugv_uwb_topic = rospy.get_param("~ugv_uwb_topic", "/dwm1001/tag/dronie/position")
        rospy.loginfo("Subscribing to UAV UWB at {}".format(self.uav_uwb_topic))
        rospy.loginfo("Subscribing to UGV UWB at {}".format(self.ugv_uwb_topic))

        self.uav_uwb_subscriber = rospy.Subscriber(self.uav_uwb_topic, PoseStamped, self.uav_uwb_cb)
        self.ugv_uwb_subscriber = rospy.Subscriber(self.ugv_uwb_topic, PoseStamped, self.ugv_uwb_cb)

        # UGV VIO pose (lower freq)
        self.ugv_vio_pos = Odometry()
        self.ugv_vio_topic = rospy.get_param("~ugv_vio_topic", "/ugv/t265/odom/sample")
        rospy.loginfo("Subscribing to UGV VIO odometry at {}".format(self.ugv_vio_topic))

        self.ugv_vio_subscriber = rospy.Subscriber(self.ugv_vio_topic, Odometry, self.ugv_vio_cb)

        # Publisher for actual control
        self.publishing_objective = False
        self.waypoint_pub_topic = rospy.get_param('~waypoint_pub_topic', "/dwm1001/tag/dronie/position")
        self.control_pub = rospy.Publisher(self.waypoint_pub_topic, PoseStamped, queue_size=10)
        
        # Keep track of offboard state
        self.offboard_state = String()
        self.offboard_state_topic = rospy.get_param("offboard_state_topic", "offboard/state")
        rospy.loginfo("Subscribing to offboard state at {}".format(self.offboard_state_topic))

        self.offbord_state_sub = rospy.Subscriber(self.offboard_state_topic, String, self.update_offboard_state_cb)

        # Service for changing to external offboard mode
        self.pub_state_mode = rospy.Publisher('/uav/offboard/mode', String, queue_size=10)
        self.set_ofboard_mode_client  = rospy.ServiceProxy("/uav/offboard/cmd/mode", OffMode)

        # 1D lidar (height)
        self.lidar_topic = rospy.get_param('~lidar_topic', "/uav/tfmini_ros_node/range")
        self.lidar_subscriber = rospy.Subscriber(self.lidar_topic, Range, self.lidar_cb)

        self.lidarz = 0.3

        # Ranging subscribers
        self.custom_uwb_rangeA_sub = rospy.Subscriber("/dwm1001/tag_A/distance", Float64, self.custom_uwbA_cb)
        self.custom_uwb_rangeB_sub = rospy.Subscriber("/dwm1001/tag_B/distance", Float64, self.custom_uwbB_cb)
        self.custom_uwb_rangeC_sub = rospy.Subscriber("/dwm1001/tag_C/distance", Float64, self.custom_uwbC_cb)
        self.custom_uwb_rangeD_sub = rospy.Subscriber("/dwm1001/tag_D/distance", Float64, self.custom_uwbD_cb)

        self.custom_uwb_ranges = numpy.ones(4)
        self.custom_uwb_stamps = [rospy.Time()] * 4
        self.num_uwb_in_use = 4
        self.using_custom_uwb = True    # Do not use Decawave's DRTLS
        self.min_uwb_ranges = False     # At least 2 transceivers should be active...

        self.ugv_x0 = 0.6
        self.ugv_y0 = 0.6
        
        # UWB pairs to calculate relative pos and average
        # 3rd element means x is calculated with cos (+1) or sin (-1)
        # 4th, 5th elements have to be added to x,y respectively
        # 6th element is the third side of the triangle to estimate angle
        self.uwb_pairs = [
            [0, 3, 1, 0, 0, self.ugv_x0],
            [1, 2, 1, 0, self.ugv_y0, self.ugv_x0],
            [0, 1, -1, 0, 0, self.ugv_y0],
            [3, 2, -1, self.ugv_x0, 0, self.ugv_y0]
        ]


    def update_current_pos_cb(self, pos) :
        '''
            Update position from mavros local pose (callback)
        '''
        self.pos = pos

    def uav_uwb_cb(self, pos) :
        '''
            Update UAV UWB position (callback)
        '''
        self.uav_uwb_pos = pos
        
    def ugv_uwb_cb(self, pos) :
        '''
            Update UGV UWB position (callback)
        '''
        self.ugv_uwb_pos = pos

    def update_offboard_state_cb(self, state) :
        '''
            Update offboard state (callback)
        '''
        self.offboard_state = state.data

    def ugv_vio_cb(self, odom) :
        '''
            Update UGV VIO odom (callback)
        '''
        self.ugv_vio_pos = odom

    def custom_uwbA_cb(self, range) :
        '''
            Update range to custom UWB A
        '''
        self.custom_uwb_ranges[0] = range.data - 0.3
        if self.custom_uwb_ranges[0] < 0 :
            self.custom_uwb_ranges[0] = 0
        self.custom_uwb_stamps[0] = rospy.Time.now()

    def custom_uwbB_cb(self, range) :
        '''
            Update range to custom UWB B
        '''
        self.custom_uwb_ranges[1] = range.data - 0.3
        if self.custom_uwb_ranges[1] < 0 :
            self.custom_uwb_ranges[1] = 0
        self.custom_uwb_stamps[1] = rospy.Time.now()

    def custom_uwbC_cb(self, range) :
        '''
            Update range to custom UWB C
        '''
        self.custom_uwb_ranges[2] = range.data - 0.3
        if self.custom_uwb_ranges[2] < 0 :
            self.custom_uwb_ranges[2] = 0
        self.custom_uwb_stamps[2] = rospy.Time.now()

    def custom_uwbD_cb(self, range) :
        '''
            Update range to custom UWB D
        '''
        self.custom_uwb_ranges[3] = range.data - 0.3
        if self.custom_uwb_ranges[3] < 0 :
            self.custom_uwb_ranges[3] = 0
        self.custom_uwb_stamps[3] = rospy.Time.now()

    def lidar_cb(self, range) :
        '''
            Update ground truth position
        '''
        self.lidarz = range.range

    def check_min_uwb_ranges(self) :
        '''
            Checks at least two (usable) ranges are available
        '''
        cnt = 0
        diffs = [rospy.Time.now() - stamp - rospy.Duration(self.max_pos_delay) for stamp in self.custom_uwb_stamps]
        for pair in self.uwb_pairs :
            if diffs[pair[0]] < rospy.Duration(0) and diffs[pair[1]] < rospy.Duration(0) :
                cnt += 1
        if cnt > 1 :
            self.min_uwb_ranges = True
        else :
            self.min_uwb_ranges = False

    def calculate_drone_locate_area(self):
        '''
            Calculates where the drone locate of the tage, top-right, top-left, bottom-right, bottom-left
        '''
        if (self.custom_uwb_ranges[0] <= self.custom_uwb_ranges[1] and custom_uwb_ranges[1] > abs(self.ugv_y0)  \
           or (self.custom_uwb_ranges[3] >= self.custom_uwb_ranges[2] and self.custom_uwb_ranges[2] > abs(self.ugv_y0)): 
            y = 1
        else:
            y = -1
        if (self.custom_uwb_ranges[0] <= self.custom_uwb_ranges[3] and custom_uwb_ranges[3] > abs(self.ugv_x0)  \
           or (self.custom_uwb_ranges[1] <= self.custom_uwb_ranges[2] and self.custom_uwb_ranges[2] > abs(self.ugv_x0)): 
            x = -1
        else:
            x = 1
        return (x, y)
        
    def calculate_relative_uwb_poses(self) :
        '''
            Calculates relative UGV-UAV position based on 2-4 transceivers on the UGV
        '''
        ground_distances = self.custom_uwb_ranges * numpy.cos( numpy.arcsin(self.lidarz / self.custom_uwb_ranges) )

        est_cnt = 0 # Count how many pairs of transceivers we use to average estimation
        est_x = 0
        est_y = 0

        # UWB pairs to calculate relative pos and average
        # 3rd element means x is calculated with cos (+1) or sin (-1)
        # 4th, 5th elements have to be added to x,y respectively (offsets)
        # 6th element is the third side of the triangle to estimate angle
        diffs = [rospy.Time.now() - stamp - rospy.Duration(self.max_pos_delay) for stamp in self.custom_uwb_stamps]
        for pair in self.uwb_pairs :
            if diffs[pair[0]] < rospy.Duration(0) and diffs[pair[1]] < rospy.Duration(0) :
                est_arg = ( ground_distances[pair[0]]**2 + pair[5]**2 - ground_distances[pair[1]] **2 ) / (2 * ground_distances[pair[0]] * pair[5] )
                if est_arg > -1 and est_arg < 1 :
                    est_theta = math.acos( est_arg )
                    print("Pair {} -- {}  =========> Theta = {}".format(pair[0], pair[1], est_theta))
                    if pair[2] > 0 :
                        est_x += ground_distances[pair[0]] * math.cos(est_theta) + pair[3]
                        est_y += ground_distances[pair[0]] * math.sin(est_theta) + pair[4]
                    else :
                        est_x += ground_distances[pair[0]] * math.sin(est_theta) + pair[3]
                        est_y += ground_distances[pair[0]] * math.cos(est_theta) + pair[4]
                    est_cnt += 1
        
        if est_cnt > 0 :
            est_relative_pos = numpy.array([est_x, est_y]) / est_cnt
            print("Relative position estimate: ({})".format(est_relative_pos))

            # "Fake" UGV pos (compared to DRTLS UWB)
            self.ugv_uwb_pos = PoseStamped()
            self.ugv_uwb_pos.header.stamp = rospy.Time.now()
            self.ugv_uwb_pos.pose.position.x = 0
            self.ugv_uwb_pos.pose.position.y = 0
            self.ugv_uwb_pos.pose.position.z = 0

            # "Fake" UAV pos (compared to DRTLS UWB)
            self.ugv_uwb_pos = PoseStamped()
            self.ugv_uwv_pos.header.stamp = rospy.Time.now()
            self.ugv_uwb_pos.pose.position.x = est_relative_pos[0]
            self.ugv_uwb_pos.pose.position.y = est_relative_pos[1]
            self.ugv_uwb_pos.pose.position.z = self.lidarz

        else :
            rospy.logerr("Could not triangulate with any pair of UGV transceivers.")

    def publish_dist_to_target(self, target) :
        '''
            Publish distance to target (timer callback)
        '''
        r = Range()
        r.header.stamp = rospy.Time.now()
        r.range = self.dist_to_target
        self.dist_to_target_pub.publish(r)

    def update_objective(self, target) :
        '''
            Update objective waypoint in order to move towards target and land (timer callback)
        '''
        self.objective = PoseStamped()

        if self.using_custom_uwb :

            # Check at least two ranges are available
            self.check_min_uwb_ranges()
            if self.min_uwb_ranges :
                self.calculate_relative_uwb_poses()

        if rospy.Time.now() - self.ugv_uwb_pos.header.stamp > rospy.Duration(self.max_pos_delay) :
            self.publishing_objective = False
            rospy.logwarn("Not receiving UGV UWB pose updates...")
        elif rospy.Time.now() - self.uav_uwb_pos.header.stamp > rospy.Duration(self.max_pos_delay)  and not self.using_custom_uwb :
            self.publishing_objective = False
            rospy.logwarn("Not receiving UAV UWB pose updates...")
        elif rospy.Time.now() - self.pos.header.stamp > rospy.Duration(self.max_pos_delay)  and not self.using_custom_uwb :
            self.publishing_objective = False
            rospy.logwarn("Not receiving MAVROS local POS update...")
        else :
            self.publishing_objective = True
            ugv_pos = numpy.array([
                self.ugv_uwb_pos.pose.position.x,
                self.ugv_uwb_pos.pose.position.y
            ])
            uav_pos = numpy.array([
                self.uav_uwb_pos.pose.position.x,
                self.uav_uwb_pos.pose.position.y
            ])
            move_dir = ugv_pos - uav_pos
            self.dist_to_target = numpy.linalg.norm(move_dir)
            if self.dist_to_target > 0.05 :
                move_dir = self.waypoint_step * move_dir / self.dist_to_target
            
            self.objective = self.pos
            self.objective.header.stamp = rospy.Time.now()
            self.objective.pose.position.x += move_dir[0]
            self.objective.pose.position.y += move_dir[1]

            if self.dist_to_target > self.closing_dist :
                self.objective.pose.position.z = self.approaching_altitude
            elif self.dist_to_target > self.landing_dist :
                self.objective.pose.position.z = self.closing_altitude
            elif self.dist_to_target <= self.landing_dist and self.dist_to_target > 0 :
                self.objective.pose.position.z = self.landing_altitude
            else :
                rospy.logerr("Distance to target of {} does not make sense...".format(self.dist_to_target))

            # Clone orientation to UGV's
            self.objective.pose.orientation.x = 0#self.ugv_vio_pos.pose.pose.orientation.x
            self.objective.pose.orientation.y = 0#self.ugv_vio_pos.pose.pose.orientation.y
            self.objective.pose.orientation.z = 0#self.ugv_vio_pos.pose.pose.orientation.z
            self.objective.pose.orientation.w = 1#self.ugv_vio_pos.pose.pose.orientation.w

            self.control_pub.publish(self.objective)

    def run(self) :
        '''
            Infinite loop that flies the drone
        '''

        # Set a rospy state check rate and landing check rate
        flag_check_rate = rospy.Rate(2.0)
        land_check_rate = rospy.Rate(10.0)

        # Set objective update timer
        time.sleep(1)
        self.objective_timer = rospy.Timer(rospy.Duration(0.1), self.update_objective)

        # Set distance to target publish timer
        self.dist_to_target_timer = rospy.Timer(rospy.Duration(0.1), self.publish_dist_to_target)

        # Wait until objective is being published
        while not self.publishing_objective and not (self.using_custom_uwb and self.min_uwb_ranges) :
            rospy.loginfo("Waiting for all control data to be available...")
            flag_check_rate.sleep()
            self.check_min_uwb_ranges()

        # Set offboard mode to external
        rospy.loginfo("Setting offboard mode to external...")
        rospy.wait_for_service('/uav/offboard/cmd/mode')
        try:
            mode = String()
            mode.data = "external_control"
            self.pub_state_mode.publish(mode)
            self.set_ofboard_mode_client("external_control")
        except rospy.ServiceException as e:
            print("Service failed: {}. Offboard mode cannot be changed to external control.".format(e))

        # Start flying towards target and check when we should land
        rospy.loginfo("Everything in order. Let's fly.")
        try:
            while not rospy.is_shutdown() :

                if self.offboard_state != "external" :
                    pass # TODO print warning and try to change or do something

                else:
                    pass # TODO everything normal, wait to be on position to land

                # Update objective position and publish it               
                land_check_rate.sleep()

        except KeyboardInterrupt :
            rospy.logerr('Keyboard Interrupt detected! Trying to land')

        # Stop objective update timer and land
        self.objective_timer.shutdown()
        self.dist_to_target_timer.shutdown()
        rospy.loginfo("Mission Completed. Landing...")
        rospy.wait_for_service('/mavros/cmd/land')


if __name__ == '__main__':
    '''
        Run the node
    '''
    try:

        # Create new control object
        control = LandingControl()

        # Run the mission control
        control.run()

    except rospy.ROSInterruptException:

        control.objective_timer.shutdown()
        control.dist_to_target_timer.shutdown()
        rospy.loginfo("Mission abruptly stopped. Trying to land...")
        rospy.wait_for_service('/mavros/cmd/land')