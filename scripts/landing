#!/usr/bin/env python

import os
import sys
import math
import time
import rospy
import numpy

from std_msgs.msg       import Float64
from std_msgs.msg       import String
from nav_msgs.msg       import Odometry
from sensor_msgs.msg    import Range
from geometry_msgs.msg  import PoseStamped

from offboard_control.srv  import flight_mode as OffMode

class LandingControl() :

    def __init__(self) :
        '''
            Test node to land a UAV on a UGV based on UWB ranging.
            Landing options:
                - Use external UWB anchors to position both vehicles
                - Use single UAV-UGV range measurement + VIO on both vehicles
                - Use multiple UWB transceivers on UGV to estimate relative positions
                - Use multiple UWB transceivers on both UGV and UAV to estimate relative poses
        '''

        # Init node
        rospy.init_node('UWB_VIO_Landing', anonymous=False)

        # Positions for navigation
        self.pos = PoseStamped()
        self.uav_uwb_pos = PoseStamped()
        self.ugv_uwb_pos = PoseStamped()
        self.objective = PoseStamped()

        self.max_pos_delay = rospy.get_param("~max_pos_delay", 0.2)
        self.waypoint_step = rospy.get_param("~waypoint_step", 0.2)

        # Control altitudes
        self.approaching_altitude = rospy.get_param("~approaching_altitude", 1.2)
        self.closing_altitude = rospy.get_param("~closing_altitude", 0.8)
        self.landing_altitude = rospy.get_param("~landing_altitude", 0.48)

        self.closing_dist = rospy.get_param("~closing_dist", 1)
        self.landing_dist = rospy.get_param("~landing_dist", 0.1)

        # Publish distance to target in a topic
        self.dist_to_target_topic = rospy.get_param("~dist_to_target_topic", "landing/distance")
        self.dist_to_target = -1
        self.dist_to_target_pub = rospy.Publisher(self.dist_to_target_topic, Range, queue_size=10)

        # Get pos from PX4 EKF2 that already integrates VIO and/or others
        self.local_pos_topic =  rospy.get_param("~local_pos_topic", "/uav/mavros/local_position/pose")
        rospy.loginfo("Subscribing to local (mavros) position at {}".format(self.local_pos_topic))

        self.local_pos_sub = rospy.Subscriber(self.local_pos_topic, PoseStamped, self.update_current_pos_cb)

        # Wait to get local pos lock
        sys.stdout.write("Waiting for (mavros) local pos lock...")
        while not self.pos.header.stamp :
            sys.stdout.write("..")
            sys.stdout.flush()
            time.sleep(0.1)
        self.home_pos = self.pos
        rospy.loginfo("Home position locked: \n{}".format(self.pos.pose))

        # UWB Subscribers
        self.uav_uwb_topic = rospy.get_param("~uav_uwb_topic", "/dwm1001/tag/dronie/position")
        self.ugv_uwb_topic = rospy.get_param("~ugv_uwb_topic", "/dwm1001/tag/dronie/position")
        rospy.loginfo("Subscribing to UAV UWB at {}".format(self.uav_uwb_topic))
        rospy.loginfo("Subscribing to UGV UWB at {}".format(self.ugv_uwb_topic))

        self.uav_uwb_subscriber = rospy.Subscriber(self.uav_uwb_topic, PoseStamped, self.uav_uwb_cb)
        self.ugv_uwb_subscriber = rospy.Subscriber(self.ugv_uwb_topic, PoseStamped, self.ugv_uwb_cb)

        # UGV VIO pose (lower freq)
        self.ugv_vio_pos = Odometry()
        self.ugv_vio_topic = rospy.get_param("~ugv_vio_topic", "/ugv/t265/odom/sample")
        rospy.loginfo("Subscribing to UGV VIO odometry at {}".format(self.ugv_vio_topic))

        self.ugv_vio_subscriber = rospy.Subscriber(self.ugv_vio_topic, Odometry, self.ugv_vio_cb)

        # Publisher for actual control
        self.publishing_objective = False
        self.waypoint_pub_topic = rospy.get_param('~waypoint_pub_topic', "/dwm1001/tag/dronie/position")
        self.control_pub = rospy.Publisher(self.waypoint_pub_topic, PoseStamped, queue_size=10)
        
        # Keep track of offboard state
        self.offboard_state = String()
        self.offboard_state_topic = rospy.get_param("offboard_state_topic", "offboard/state")
        rospy.loginfo("Subscribing to offboard state at {}".format(self.offboard_state_topic))

        self.offbord_state_sub = rospy.Subscriber(self.offboard_state_topic, String, self.update_offboard_state_cb)

        # Service for changing to external offboard mode
        self.pub_state_mode = rospy.Publisher('/uav/offboard/mode', String, queue_size=10)
        self.set_ofboard_mode_client  = rospy.ServiceProxy("/uav/offboard/cmd/mode", OffMode)

        # 1D lidar (height)
        self.lidar_topic = rospy.get_param('~lidar_topic', "/uav/tfmini_ros_node/range")
        self.lidar_subscriber = rospy.Subscriber(self.lidar_topic, Range, self.lidar_cb)

        self.lidarz = 0

        # Ranging subscribers
        self.custom_uwb_rangeA_sub = rospy.Subscriber("/dwm1001/tag_A/distance", Float64, self.custom_uwbA_cb)
        self.custom_uwb_rangeB_sub = rospy.Subscriber("/dwm1001/tag_B/distance", Float64, self.custom_uwbB_cb)
        self.custom_uwb_rangeC_sub = rospy.Subscriber("/dwm1001/tag_C/distance", Float64, self.custom_uwbC_cb)
        self.custom_uwb_rangeD_sub = rospy.Subscriber("/dwm1001/tag_D/distance", Float64, self.custom_uwbD_cb)

        self.custom_uwb_ranges = numpy.zeros(4) - 1
        self.num_uwb_in_use = 4
        self.using_custom_uwb = True

        self.ugv_x0 = 0.6
        self.ugv_y0 = 0.6


    def update_current_pos_cb(self, pos) :
        '''
            Update position from mavros local pose (callback)
        '''
        self.pos = pos

    def uav_uwb_cb(self, pos) :
        '''
            Update UAV UWB position (callback)
        '''
        self.uav_uwb_pos = pos
        
    def ugv_uwb_cb(self, pos) :
        '''
            Update UGV UWB position (callback)
        '''
        self.ugv_uwb_pos = pos

    def update_offboard_state_cb(self, state) :
        '''
            Update offboard state (callback)
        '''
        self.offboard_state = state.data

    def ugv_vio_cb(self, odom) :
        '''
            Updata UGV VIO odom (callback)
        '''
        self.ugv_vio_pos = odom

    def custom_uwbA_cb(self, range) :
        '''
            Update range to custom UWB A
        '''
        self.custom_uwb_ranges[0] = range.data - 0.3
        if self.custom_uwb_ranges[0] < 0 :
            self.custom_uwb_ranges[0] = 0

    def custom_uwbB_cb(self, range) :
        '''
            Update range to custom UWB B
        '''
        self.custom_uwb_ranges[1] = range.data - 0.3
        if self.custom_uwb_ranges[1] < 0 :
            self.custom_uwb_ranges[1] = 0

    def custom_uwbC_cb(self, range) :
        '''
            Update range to custom UWB C
        '''
        self.custom_uwb_ranges[2] = range.data - 0.3
        if self.custom_uwb_ranges[2] < 0 :
            self.custom_uwb_ranges[2] = 0

    def custom_uwbD_cb(self, range) :
        '''
            Update range to custom UWB D
        '''
        self.custom_uwb_ranges[3] = range.data - 0.3
        if self.custom_uwb_ranges[3] < 0 :
            self.custom_uwb_ranges[3] = 0

    def lidar_cb(self, range) :
        '''
            Update ground truth position
        '''
        self.lidarz = pos.range

    def calculate_relative_uwb_poses(self) :
        '''
            TODO
        '''
        ground_distances = self.custom_uwb_ranges * numpy.cos( numpy.arcsin(self.lidarz / self.custom_uwb_ranges) )
        print(ground_distances)

        est_cnt = 0 # Count how many pairs of transceivers we use
        est_x = 0
        est_y = 0

        # Estimate using one pair of UGV transceivers
        est_arg = ( ground_distances[0]**2 + self.ugv_x0**2 - ground_distances[3] **2 ) / (2 * ground_distances[0] * self.ugv_x0 )
        if est_arg > -1 and est_arg < 1 :
            est_theta = math.acos( est_arg )
            est_x += ground_distances[0] * math.cos(est_theta)
            est_y += ground_distances[0] * math.sin(est_theta)
            est_cnt += 1

        # Estimate using the second pair of UGV transceivers
        est_arg = ( ground_distances[1]**2 + self.ugv_x0**2 - ground_distances[2] **2 ) / (2 * ground_distances[1] * self.ugv_x0 )
        if est_arg > -1 and est_arg < 1 :
            est_theta = math.acos( est_arg )
            est_x += ground_distances[1] * math.cos(est_theta)
            est_y += ground_distances[1] * math.sin(est_theta) + self.ugv_y0
            est_cnt += 1

        # Again
        est_arg = ( ground_distances[0]**2 + self.ugv_y0**2 - ground_distances[1] **2 ) / (2 * ground_distances[0] * self.ugv_y0 )
        if est_arg > -1 and est_arg < 1 :
            est_theta = math.acos( est_arg )
            est_x += ground_distances[0] * math.sin(est_theta)
            est_y += ground_distances[0] * math.cos(est_theta)
            est_cnt += 1

        # And again
        print( ( ground_distances[3]**2 + self.ugv_y0**2 - ground_distances[2] **2 ) / (2 * ground_distances[3] * self.ugv_y0 ) )
        est_arg = ( ground_distances[3]**2 + self.ugv_y0**2 - ground_distances[2] **2 ) / (2 * ground_distances[3] * self.ugv_y0 )
        if est_arg > -1 and est_arg < 1 :
            est_theta = math.acos( est_arg )
            est_x += ground_distances[0] * math.sin(est_theta) + self.ugv_x0
            est_y += ground_distances[0] * math.cos(est_theta)
            est_cnt += 1

        est_relative_pos = numpy.array([est_x, est_y]) / est_cnt

        print("Position estimates: ({})".format(est_relative_pos))

    def publish_dist_to_target(self, target) :
        '''
            Publish distance to target (timer callback)
        '''
        r = Range()
        r.header.stamp = rospy.Time.now()
        r.range = self.dist_to_target
        self.dist_to_target_pub.publish(r)

    def update_objective(self, target) :
        '''
            Update objective waypoint in order to move towards target and land (timer callback)
        '''
        self.calculate_relative_uwb_poses()
        return
        self.objective = PoseStamped()

        if rospy.Time.now() - self.ugv_uwb_pos.header.stamp > rospy.Duration(self.max_pos_delay)  and not self.using_custom_uwb :
            self.publishing_objective = False
            # if self.publishing_objective :
            rospy.logwarn("Not receiving UGV UWB pose updates...")
        elif rospy.Time.now() - self.uav_uwb_pos.header.stamp > rospy.Duration(self.max_pos_delay)  and not self.using_custom_uwb :
            self.publishing_objective = False
            # if self.publishing_objective :
            rospy.logwarn("Not receiving UAV UWB pose updates...")
        elif rospy.Time.now() - self.pos.header.stamp > rospy.Duration(self.max_pos_delay)  and not self.using_custom_uwb :
            self.publishing_objective = False
            # if self.publishing_objective :
            rospy.logwarn("Not receiving MAVROS local POS update...")
        else :
            self.publishing_objective = True
            ugv_pos = numpy.array([
                self.ugv_uwb_pos.pose.position.x,
                self.ugv_uwb_pos.pose.position.y
            ])
            uav_pos = numpy.array([
                self.uav_uwb_pos.pose.position.x,
                self.uav_uwb_pos.pose.position.y
            ])
            move_dir = ugv_pos - uav_pos
            self.dist_to_target = numpy.linalg.norm(move_dir)
            if self.dist_to_target > 0.05 :
                move_dir = self.waypoint_step * move_dir / self.dist_to_target
            
            self.objective = self.pos
            self.objective.header.stamp = rospy.Time.now()
            self.objective.pose.position.x += move_dir[0]
            self.objective.pose.position.y += move_dir[1]

            if self.dist_to_target > self.closing_dist :
                self.objective.pose.position.z = self.approaching_altitude
            elif self.dist_to_target > self.landing_dist :
                self.objective.pose.position.z = self.closing_altitude
            elif self.dist_to_target <= self.landing_dist and self.dist_to_target > 0 :
                self.objective.pose.position.z = self.landing_altitude
            else :
                rospy.logerr("Distance to target of {} does not make sense...".format(self.dist_to_target))

            # Clone orientation to UGV's
            self.objective.pose.orientation.x = 0#self.ugv_vio_pos.pose.pose.orientation.x
            self.objective.pose.orientation.y = 0#self.ugv_vio_pos.pose.pose.orientation.y
            self.objective.pose.orientation.z = 0#self.ugv_vio_pos.pose.pose.orientation.z
            self.objective.pose.orientation.w = 1#self.ugv_vio_pos.pose.pose.orientation.w

            self.control_pub.publish(self.objective)

    def run(self) :
        '''
            Infinite loop that flies the drone
        '''

        # Set a rospy state check rate and landing check rate
        flag_check_rate = rospy.Rate(2.0)
        land_check_rate = rospy.Rate(10.0)

        # Set objective update timer
        time.sleep(1)
        self.objective_timer = rospy.Timer(rospy.Duration(0.1), self.update_objective)

        # Set distance to target publish timer
        self.dist_to_target_timer = rospy.Timer(rospy.Duration(0.1), self.publish_dist_to_target)

        # Wait until objective is being published
        while not self.publishing_objective and not self.using_custom_uwb :
            rospy.loginfo("Waiting for all control data to be available...")
            flag_check_rate.sleep()

        # Set offboard mode to external
        rospy.loginfo("Setting offboard mode to external...")
        rospy.wait_for_service('/uav/offboard/cmd/mode')
        try:
            mode = String()
            mode.data = "external_control"
            self.pub_state_mode.publish(mode)
            self.set_ofboard_mode_client("external_control")
        except rospy.ServiceException as e:
            print("Service failed: {}. Offboard mode cannot be changed to external control.".format(e))

        # Start flying towards target and check when we should land
        rospy.loginfo("Everything in order. Let's fly.")
        try:
            while not rospy.is_shutdown() :

                if self.offboard_state != "external" :
                    pass # TODO print warning and try to change or do something

                else:
                    pass # TODO everything normal, wait to be on position to land

                # Update objective position and publish it               
                land_check_rate.sleep()

        except KeyboardInterrupt :
            rospy.logerr('Keyboard Interrupt detected! Trying to land')

        # Stop objective update timer and land
        self.objective_timer.shutdown()
        self.dist_to_target_timer.shutdown()
        rospy.loginfo("Mission Completed. Landing...")
        rospy.wait_for_service('/mavros/cmd/land')


if __name__ == '__main__':
    '''
        Run the node
    '''
    try:

        # Create new control object
        control = LandingControl()

        # Run the mission control
        control.run()

    except rospy.ROSInterruptException:

        control.objective_timer.shutdown()
        control.dist_to_target_timer.shutdown()
        rospy.loginfo("Mission abruptly stopped. Trying to land...")
        rospy.wait_for_service('/mavros/cmd/land')