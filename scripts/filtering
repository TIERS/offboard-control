#!/usr/bin/env python

import os
import sys
import math
import time
import copy
import rospy
import numpy
import mpl_toolkits as mplt

from std_msgs.msg       import String
from std_msgs.msg       import Float64

from nav_msgs.msg       import Odometry

from sensor_msgs.msg    import Range

from geometry_msgs.msg  import PoseStamped

from pfilter            import ParticleFilter
from pfilter            import squared_error
from pfilter            import independent_sample

from mplt.mplot3d       import Axes3D


class UWBParticleFilter() :
    '''
        ROS Node that estimates position of a single or a set of UWB initiators
        with respect to a set of responders in known positions. It uses a particle
        filter to estimate the position.
    '''

    def __init__(self) :
        '''
            TODO
        '''

        # Init node
        rospy.init_node('UWB_Particle_Filter', anonymous=False)

    
    def velocity(self, x, move=None, z = None) :
    '''
        Use VIO to update position
    '''
    xp = x + move
    return xp

    def add_noise(self, x, move=None, z = None) :
        '''

        '''
        xp = x + np.random.normal(0, noise, x.shape)
        return xp

    def calc_dists(self, x, move=None, z = None) :
        '''
            Given (Nx2) matrix of positions,
            create N arrays each with the 4
            ranges that should be observed
            from the given positions
        '''
        particles_z = np.ones((x.shape[0],1)) * z
        x3d = np.append(x, particles_z, axis=1)

        offsets = np.array([
            [0, 0, 0.4],
            [0, 0.56, 0.4],
            [0.56, 0.56, 0.4],
            [0.56, 0, 0.4]
        ])
        y = np.zeros((x.shape[0], 4))
        for i, p in enumerate(x3d) :
            for j, q in enumerate(offsets) :
                y[i][j] = np.linalg.norm(p - q)

        return y

    def calc_weights(self, hypotheses, observations, move=None, z = None) :
        return squared_error(hypotheses, observations, sigma=1.2)